# Project4-a SM3的软件实现与优化 
## 一、实验背景
SM3 算法是中国国家密码管理局发布的消息摘要算法，全称为 “商用密码 SM3 杂凑算法”。2010 年正式发布，2016 年发布了正式的国家标准 GB/T 32905-2016。它类似于国际上广泛应用的 SHA-256 算法，具有中国自主知识产权，用于提供数据完整性校验和安全性认证。以下是具体介绍：
-   **算法原理**：
    -   **消息填充**：将输入消息填充至长度为 512 位的倍数。具体是先在消息末尾添加比特 “1”，再添加若干比特 “0”，使消息长度对 512 取模余 448，最后再添加一个 64 位比特串，用于表示原始消息的长度。
    -   **消息扩展**：对填充后的消息进行扩展，将每个 512 位的消息分组扩展成 132 个 32 位的字，用于后续的迭代压缩运算。
    -   **迭代压缩**：将扩展后的消息分块并逐块迭代压缩，通过特定的压缩函数进行 64 轮迭代运算，最后输出 256 位的摘要。
-   **算法特点**：
    -   **抗碰撞性**：通过优化的消息扩展和压缩算法，SM3 提高了抗碰撞能力，能有效抵抗碰撞攻击，其设计抗碰撞能力达到\(2^{128}\)。
    -   **抗篡改性**：输出的 256 位摘要长度及算法特性，使得 SM3 能敏锐地检测数据是否被篡改，只要数据有任何变动，生成的摘要就会截然不同。
    -   **高效性**：SM3 算法在硬件和软件上都能实现高效的摘要计算，无论是在普通计算机上，还是各种嵌入式系统和移动设备中，都能快速执行。
-   **应用场景**：
    -   **数字签名**：可作为数字签名算法的一部分，用于生成消息摘要并参与签名过程。例如在基于 SM2 的签名体系中，通常先使用 SM3 对消息进行摘要，然后再使用 SM2 进行签名。
    -   **身份认证**：在用户登录等场景中，可对用户密码进行 SM3 哈希处理，将哈希值存储在服务器中。用户登录时，输入的密码同样经过 SM3 哈希后与服务器中的值对比，以此验证密码正确性。
    -   **电子支付**：可用于对交易明细等重要信息进行哈希计算，确保交易数据的完整性与不可篡改性，保障电子支付的安全。
    -   **区块链领域**：常用于区块数据的哈希计算和链上数据的完整性验证，有助于维护区块链的安全和稳定。

## 二、SM3实现思路与过程
### 实现思路
1.  **数据预处理（消息填充）**
    
    -   首先计算原始消息的比特长度，将其转换为 64 位无符号整数
    -   在消息末尾追加一个 "1" 比特，再填充若干 "0" 比特，使总长度模 512 等于 448
    -   最后追加 64 位原始消息长度（小端或大端需符合标准）
2.  **消息分组与扩展**
    
    -   将填充后的消息按 512 位分组，逐组处理
    -   每组扩展为 132 个 32 位字：前 68 个通过特定变换生成，后 64 个由前 68 个计算得出
    -   扩展过程需实现 P0、P1 等置换函数，以及循环左移等操作
3.  **迭代压缩**
    
    -   初始化 8 个 32 位寄存器（IV 值固定）
    -   对每个 512 位分组进行 64 轮压缩运算，每轮使用不同的常量和扩展字
    -   实现压缩函数中的布尔函数（FF、GG）和置换函数（P0、P1）
    -   每轮更新寄存器状态，完成一组处理后与原始寄存器值相加
4.  **结果输出**
    
    -   所有分组处理完成后，将 8 个寄存器的值按顺序拼接
    -   转换为 64 位十六进制字符串，即为最终的 256 位哈希值
 
### 实现过程
#### 1. 消息填充
```cpp
size_t block_len = ((len + 8 + 63) / 64) * 64;
uint8_t* padded = new uint8_t[block_len]();
memcpy(padded, data, len);
padded[len] = 0x80;  // 添加1比特标记
uint64_t bit_len = len * 8;
memcpy(padded + block_len - 8, &bit_len, 8);  // 添加消息长度
```
#### 2. 初始化状态
```cpp
uint32_t V[8];
memcpy(V, IV, sizeof(IV));  // 使用预定义初始向量
```
#### 3. 消息扩展
```cpp
for (int j = 0; j < 16; j++) {
    uint32_t word;
    memcpy(&word, padded + i + j * 4, 4);
    W[j] = byteswap32(word);  // 大端转换
}

for (int j = 16; j < 68; j++) {
    W[j] = P1(W[j-16] ^ W[j-9] ^ ROTL32(W[j-3], 15)) 
          ^ ROTL32(W[j-13], 7) ^ W[j-6];
}

for (int j = 0; j < 64; j++) {
    W1[j] = W[j] ^ W[j+4];  // 生成W'
}
```
#### 4. 压缩函数
```cpp
for (int j = 0; j < 64; j++) {
    uint32_t SS1 = ROTL32(ROTL32(A, 12) + E + ROTL32(T[j], j % 32), 7);
    uint32_t SS2 = SS1 ^ ROTL32(A, 12);
    
    // 选择FF/GG函数
    if (j < 16) {
        TT1 = FF0(A, B, C) + D + SS2 + W1[j];
        TT2 = GG0(E, F, G) + H + SS1 + W[j];
    } else {
        TT1 = FF1(A, B, C) + D + SS2 + W1[j];
        TT2 = GG1(E, F, G) + H + SS1 + W[j];
    }
    
    // 更新状态
    D = C;
    C = ROTL32(B, 9);
    B = A;
    A = TT1;
    H = G;
    G = ROTL32(F, 19);
    F = E;
    E = P0(TT2);
}

// 更新哈希值
V[0] ^= A; V[1] ^= B; V[2] ^= C; V[3] ^= D;
V[4] ^= E; V[5] ^= F; V[6] ^= G; V[7] ^= H;
```

#### 5. 结果输出
```cpp
for (int i = 0; i < 8; i++) {
    uint32_t word = byteswap32(V[i]);
    memcpy(digest + i * 4, &word, 4);
}
```
## 三、优化思路与过程
#### 优化思路

1.  **SIMD并行化**：使用SSE/AVX指令加速消息处理
    
2.  **减少内存访问**：将中间数据保留在寄存器中
    
3.  **循环展开**：降低分支预测失败率和寄存器置换开销
    
4.  **指令优化**：选择高效CPU指令
    
5.  **数据对齐**：32字节对齐提升内存访问效率

#### 优化实现过程

##### 1. SIMD加速消息加载和字节序转换
```cpp
// 使用SSE加载16字节数据
__m128i w0 = _mm_loadu_si128((__m128i*)(padded + i));

// 字节序转换（大端转小端）
const __m128i bswap_mask = _mm_set_epi8(12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3);
w0 = _mm_shuffle_epi8(w0, bswap_mask);  // 单指令完成4个字的字节序转换
```
##### 2. 消息扩展优化（减少内存访问）
```cpp
// 将SIMD寄存器直接存入局部数组
_mm_store_si128((__m128i*)&W[0], w0);
_mm_store_si128((__m128i*)&W[4], w1);

// 优化后的扩展循环
for (int j = 16; j < 68; j++) {
    uint32_t temp = W[j-16] ^ W[j-9] ^ ROTL32(W[j-3], 15);
    W[j] = P1(temp) ^ ROTL32(W[j-13], 7) ^ W[j-6];
}
```
##### 3. 压缩函数优化（4轮展开+寄存器轮转）
```cpp
for (int j = 0; j < 64; j++) {
    // ... 单轮计算 ...
    
    // 每4轮进行寄存器轮转
    if (j % 4 == 3) {
        uint32_t tmp = E;
        E = D; D = C; C = B; B = A; A = H;
        H = G; G = F; F = tmp;
    }
}
```
##### 4. 指令级优化
```cpp
// 使用三元逻辑运算替代分支
#define FF(x, y, z) ((x) & (y)) | ((x) & (z)) | ((y) & (z))

// 使用LEA指令优化加法
__asm__("leal %1(%2,%3), %0" : "=r"(result) : "i"(constant), "r"(a), "r"(b));
```
##### 5. 内存访问优化
```cpp
alignas(32) uint32_t V[8];  // 32字节对齐

// 使用局部数组避免全局内存访问
uint32_t local_W[68];
memcpy(local_W, W, sizeof(local_W));
```
## 四、实验结果
如图project4-a 结果.png所示，优化效果明显
