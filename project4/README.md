# Project4-a SM3的软件实现与优化 
## 一、实验背景
SM3 算法是中国国家密码管理局发布的消息摘要算法，全称为 “商用密码 SM3 杂凑算法”。2010 年正式发布，2016 年发布了正式的国家标准 GB/T 32905-2016。它类似于国际上广泛应用的 SHA-256 算法，具有中国自主知识产权，用于提供数据完整性校验和安全性认证。以下是具体介绍：
-   **算法原理**：
    -   **消息填充**：将输入消息填充至长度为 512 位的倍数。具体是先在消息末尾添加比特 “1”，再添加若干比特 “0”，使消息长度对 512 取模余 448，最后再添加一个 64 位比特串，用于表示原始消息的长度。
    -   **消息扩展**：对填充后的消息进行扩展，将每个 512 位的消息分组扩展成 132 个 32 位的字，用于后续的迭代压缩运算。
    -   **迭代压缩**：将扩展后的消息分块并逐块迭代压缩，通过特定的压缩函数进行 64 轮迭代运算，最后输出 256 位的摘要。
-   **算法特点**：
    -   **抗碰撞性**：通过优化的消息扩展和压缩算法，SM3 提高了抗碰撞能力，能有效抵抗碰撞攻击，其设计抗碰撞能力达到\(2^{128}\)。
    -   **抗篡改性**：输出的 256 位摘要长度及算法特性，使得 SM3 能敏锐地检测数据是否被篡改，只要数据有任何变动，生成的摘要就会截然不同。
    -   **高效性**：SM3 算法在硬件和软件上都能实现高效的摘要计算，无论是在普通计算机上，还是各种嵌入式系统和移动设备中，都能快速执行。
-   **应用场景**：
    -   **数字签名**：可作为数字签名算法的一部分，用于生成消息摘要并参与签名过程。例如在基于 SM2 的签名体系中，通常先使用 SM3 对消息进行摘要，然后再使用 SM2 进行签名。
    -   **身份认证**：在用户登录等场景中，可对用户密码进行 SM3 哈希处理，将哈希值存储在服务器中。用户登录时，输入的密码同样经过 SM3 哈希后与服务器中的值对比，以此验证密码正确性。
    -   **电子支付**：可用于对交易明细等重要信息进行哈希计算，确保交易数据的完整性与不可篡改性，保障电子支付的安全。
    -   **区块链领域**：常用于区块数据的哈希计算和链上数据的完整性验证，有助于维护区块链的安全和稳定。

## 二、SM3实现思路与过程
### 实现思路
1.  **数据预处理（消息填充）**
    
    -   首先计算原始消息的比特长度，将其转换为 64 位无符号整数
    -   在消息末尾追加一个 "1" 比特，再填充若干 "0" 比特，使总长度模 512 等于 448
    -   最后追加 64 位原始消息长度（小端或大端需符合标准）
2.  **消息分组与扩展**
    
    -   将填充后的消息按 512 位分组，逐组处理
    -   每组扩展为 132 个 32 位字：前 68 个通过特定变换生成，后 64 个由前 68 个计算得出
    -   扩展过程需实现 P0、P1 等置换函数，以及循环左移等操作
3.  **迭代压缩**
    
    -   初始化 8 个 32 位寄存器（IV 值固定）
    -   对每个 512 位分组进行 64 轮压缩运算，每轮使用不同的常量和扩展字
    -   实现压缩函数中的布尔函数（FF、GG）和置换函数（P0、P1）
    -   每轮更新寄存器状态，完成一组处理后与原始寄存器值相加
4.  **结果输出**
    
    -   所有分组处理完成后，将 8 个寄存器的值按顺序拼接
    -   转换为 64 位十六进制字符串，即为最终的 256 位哈希值
 
### 实现过程
### 1. 初始化

设置8个32位初始状态值（IV）：
```cpp
state[0] = 0x7380166F;
state[1] = 0x4914B2B9;
// ... 其他状态值
```
### 2. 消息填充

-   添加比特"1"（0x80字节）
    
-   填充0直到长度满足 mod 512 = 448
    
-   添加64位消息长度（大端序）

### 3. 消息扩展
```cpp
for (int i = 0; i < 16; ++i) {
    W[i] = (block[i*4+0] << 24) | ...;
}

for (int i = 16; i < 68; ++i) {
    W[i] = P1(W[i-16] ^ W[i-9] ^ ROTL(W[i-3], 15)) ^ ...;
}
```
### 4. 压缩函数（64轮迭代）
```cpp
for (int j = 0; j < 64; ++j) {
    // 计算SS1, SS2
    // 根据轮次选择布尔函数
    // 更新工作变量A-H
}
```

### 5. 更新状态
```cpp
state[0] ^= A; state[1] ^= B; ...;
```
### 6. 输出哈希值

将8个32位状态值转换为32字节大端序输出
## 三、优化思路与过程
### 优化思路

1.  **减少寄存器置换**：
    
    -   4轮展开避免每轮寄存器移位
        
    -   保持状态变量位置相对固定
        
2.  **提高指令级并行**：
    
    -   展开循环减少分支预测失败
        
    -   减少数据依赖链
        
3.  **优化消息扩展**：
    
    -   使用SIMD并行计算（原方案）
        
    -   减少中间变量存储
        
4.  **内存访问优化**：
    
    -   优先使用寄存器而非内存
        
    -   减少不必要的内存读写
        
5.  **循环展开**：
    
    -   4轮一组处理，减少循环开销
        
    -   平衡代码大小和性能
### 优化实现过程

### 1. 4轮展开压缩函数
```cpp
for (int j = 0; j < 64; j += 4) {
    // 第1轮计算...
    // 第2轮计算...
    // 第3轮计算...
    // 第4轮计算...
}
```
-   减少75%的寄存器置换操作
    
-   保持寄存器位置相对稳定
### 2. 布尔函数动态选择
```cpp
bool useFF0 = (j < 16);
uint32_t TT1 = useFF0 ? 
    (FF0(A, B, C) + ...) :
    (FF1(A, B, C) + ...);
```
-   根据轮次动态选择布尔函数
    
-   保持算法正确性
### 3. 循环移位优化
```cpp
#define ROTL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
```
-   单表达式完成循环移位
    
-   避免分支和函数调用
### 4. 减少内存访问
```cpp
uint32_t A = state[0], B = state[1], ...;
// ... 计算过程 ...
state[0] ^= A; state[1] ^= B; ...;
```
-   使用局部变量减少类成员访问
    
-   CPU寄存器访问快于内存访问
## 四、实验结果
如图project4-a 结果.png所示，优化效果明显。
